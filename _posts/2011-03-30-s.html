---
layout: post
title: Реализация ГОСТ 28147-89
categories: ru 
---

<div dir="ltr" style="text-align: left;" trbidi="on"><a href="http://ru.wikipedia.org/wiki/%D0%93%D0%9E%D0%A1%D0%A2_28147-89">ГОСТ 28147-89</a> — советский и российский стандарт симметричного шифрования, введённый в 1990 году, также является стандартом СНГ.<br /><br />Была поставлена задача: реализовать шифрование в режиме гаммирования для процессора семейства ADSP. Алгоритм должен был быть написан на чистом Си К сожалению, процессор поддерживал только 32хбитные типы данных. Потому совсем красивого кода не получилось. С другой стороны я попытался сделать код максимально удобочитаемым и простым для изменения.<br /><br />Внешними функциями являются:<br /><pre  name="code">typedef unsigned int UINT32;<br /><br />// Задаёт синхропосылку (64 бита)<br />void SetSynchroMessage(UINT32 *synchroMessage);<br /><br />// Задаёт ключ шифрования (256 бит = 32 байта)<br />void SetKey(UINT32 *cryptKey);<br /><br />// Шифрует данные в масиве data размера size * 32bit<br />// с помощью операции гаммирования<br />void CryptData(UINT32 *data, UINT32 size);<br /></pre>Код внутри приспособлен под любые процессоры, имеющие little-endian последовательность (x86)<br /><a name='more'></a><br /><br /><pre name="code">typedef unsigned int UINT32;<br />// Задает значение регистра reg, из переменной value, в битах указаных маской mask<br />#define SETBITBYMASK(reg, mask, value) (reg = ((~mask &amp; reg) | (mask &amp; value)))<br /><br />typedef unsigned int UINT32;<br /><br />// Таблица замены<br />const UINT32 TABLE[8][16] =<br />{ // S-блоки, используемые ЦБ РФ<br /> { 4, 10,  9,  2, 13,  8,  0, 14,  6, 11,  1, 12,  7, 15,  5,  3},<br /> {14, 11,  4, 12,  6, 13, 15, 10,  2,  3,  8,  1,  0,  7,  5,  9},<br /> { 5,  8,  1, 13, 10,  3,  4,  2, 14, 15, 12,  7,  6,  0,  9, 11},<br /> { 7, 13, 10,  1,  0,  8,  9, 15, 14,  4,  6, 12, 11,  2,  5,  3},<br /> { 6, 12,  7,  1,  5, 15, 13,  8,  4, 10,  9, 14,  0,  3, 11,  2},<br /> { 4, 11, 10,  0,  7,  2,  1, 13,  3,  6,  8,  5,  9, 12, 15, 14},<br /> {13, 11,  4,  1,  3, 15,  5,  9,  0, 10, 14,  7,  6,  8,  2, 12},<br /> { 1, 15, 13,  0,  5,  7, 10,  4,  9,  2,  3, 14,  6, 11,  8, 12},<br />};<br /><br />#define CRYPT_KEY_LEN 8<br />UINT32 CRYPT_KEY[CRYPT_KEY_LEN]; // Ключ шифрования<br /><br />//UINT64 GAMMA = 0x00; // Гамма вектор (можно дать дефолтное значение и проверять на инициализацию)<br />UINT32 LOGAMMA = 0x00;<br />UINT32 HIGAMMA = 0x00;<br /><br />const UINT32 LOGAMMA_CONSTANT = 0x1010101;<br />const UINT32 LOGAMMA_BAR = 0xFEFEFEFF; // Число = 2^32 - LOGAMMA_CONSTANT<br /><br />const UINT32 HIGAMMA_CONSTANT = 0x1010104;<br />const UINT32 HIGAMMA_BAR = 0xFEFEFEFC; // Число = 2^32 - HIGAMMA_CONSTANT<br /><br />// Производит замену каждых 4х бит согласно таблице замены<br />void TableReplace(UINT32 *value)<br />{<br /> UINT32 partValue;<br /> UINT32 mask = 0xF;<br /> int i;<br /> for (i = 0; i &lt; 8; i++)<br /> {<br />  partValue = *value &amp; mask;<br />  partValue = partValue &gt;&gt; 4 * i; // Сдвигаем в начало, чтобы иметь значение в интервале (0..F)<br />  partValue = TABLE[i][partValue]; // получаем значение из таблицы<br />  partValue = partValue &lt;&lt; 4 * i; // сдвигаем на место<br />  SETBITBYMASK(*value, mask, partValue); // задаем нонове значение из таблицы<br />  mask = mask &lt;&lt; 4; // Переходим к следующему куску<br /> }<br />}<br /><br />// Циклический сдвиг влево на 11 бит<br />void RollLeft11(UINT32 *value)<br />{<br /> UINT32 mask = 0x7FF; // 0b00000000000000000000011111111111<br /> <br /> UINT32 saveValue = *value;<br /> *value = *value &lt;&lt; 11;<br /> saveValue = saveValue &gt;&gt; 21;<br /> SETBITBYMASK(*value, mask, saveValue);<br />}<br /><br />// Базовый проход кодирования<br />void BaseCryptStep(UINT32 *loBlockPart, UINT32 *hiBlockPart, UINT32 keyPart)<br />{<br /> // Оптима: можно заменить keyPart на указатель<br /> UINT32 tempPart = *loBlockPart + keyPart;<br /> <br /> TableReplace(&amp;tempPart);<br /><br /> RollLeft11(&amp;tempPart);<br /><br /> tempPart = tempPart ^ *hiBlockPart;<br /><br /> *hiBlockPart = *loBlockPart;<br /> *loBlockPart = tempPart; <br />}<br /><br />// Кодирует значение 64х бит по адресу inpetBlock<br />void CryptBlock(UINT32 *loBlockPart, UINT32 *hiBlockPart)<br />{<br /> int hiCounter, loCounter;<br /> UINT32 swapTemp;<br /><br /> for(hiCounter = 0; hiCounter &lt; 3; hiCounter++)<br />  for (loCounter = 0; loCounter &lt; 8; loCounter++)<br />  {<br />   BaseCryptStep(loBlockPart, hiBlockPart, CRYPT_KEY[loCounter]);<br />  }<br /><br /> for (loCounter = 7; loCounter &gt;= 0; loCounter--)<br /> {<br />  BaseCryptStep(loBlockPart, hiBlockPart, CRYPT_KEY[loCounter]);<br /> }<br /><br /> swapTemp = *loBlockPart;<br /> *loBlockPart = *hiBlockPart;<br /> *hiBlockPart = swapTemp;<br />}<br /><br /><br />UINT32 NextLoGamma(UINT32 loGamma)<br />{<br /> // В случае если loGamma будет больше порога, то<br /> // сумма loGamma + LOGAMMA_CONSTANT выйдет за пределы инта<br /> // Тогда нужно просто взять растояние между LOGAMMA_CONSTANT и loGamma<br /><br /> if (loGamma &lt; LOGAMMA_BAR)  <br /> {<br />  return loGamma + LOGAMMA_CONSTANT;<br /> } <br /> else<br /> {<br />  return loGamma - LOGAMMA_BAR;<br /> }<br />}<br /><br />UINT32 NextHiGamma(UINT32 hiGamma)<br />{<br /><br /> if (hiGamma &lt; HIGAMMA_BAR)  <br /> {<br />  return hiGamma + HIGAMMA_CONSTANT;<br /> } <br /> else<br /> {<br />  return hiGamma - HIGAMMA_BAR + 1;<br /> }<br />}<br /><br />// Переводит гамму в следущее состояним<br />void NextGamma()<br />{<br /> LOGAMMA = NextLoGamma(LOGAMMA);<br /> HIGAMMA = NextHiGamma(HIGAMMA);<br />}<br /><br />// Шифрует данные в масиве data размера size<br />// с помощью операции гаммирования<br />void CryptData(UINT32 *data, UINT32 size)<br />{<br /> UINT32 loCryptGamma;<br /> UINT32 hiCryptGamma;<br /><br /> UINT32 dataShift;<br /><br /> size--; // Т.к. необходимо учесть, если size - нечетное<br /> <br /> for (dataShift = 0; dataShift &lt; size; dataShift += 2)<br /> {<br />  NextGamma(); // Следущий блок гаммы<br /><br />  // Отдельные значения, т.к. GAMMA не должна быть измененна нигде кроме NextGamma()<br />  loCryptGamma = LOGAMMA;<br />  hiCryptGamma = HIGAMMA;<br />  <br />  CryptBlock(&amp;loCryptGamma, &amp;hiCryptGamma); // Его закодированый вид<br /><br />  // data64 XOR CryptBlock(GAMMA)<br />  data[dataShift]     = data[dataShift]     ^ loCryptGamma;<br />  data[dataShift + 1] = data[dataShift + 1] ^ hiCryptGamma;<br /> }<br /><br /> // Если число входящих данных было нечетным:<br /> if (dataShift == size)<br /> {<br />  NextGamma(); // Следущий блок гаммы<br /><br />  // Отдельные значения, т.к. GAMMA не должна быть измененна нигде кроме NextGamma()<br />  loCryptGamma = LOGAMMA;<br />  hiCryptGamma = HIGAMMA;<br /><br />  CryptBlock(&amp;loCryptGamma, &amp;hiCryptGamma); // Его закодированый вид<br /><br />  // data32 XOR CryptBlock(GAMMA)<br />  data[dataShift] = data[dataShift] ^ loCryptGamma;<br /> }<br /><br />}<br /><br />// Задаёт синхропосылку (64 бита)<br />void SetSynchroMessage(UINT32 *synchroMessage)<br />{<br /> LOGAMMA = *synchroMessage;<br /> HIGAMMA = *(synchroMessage + 1);<br /> CryptBlock(&amp;LOGAMMA, &amp;HIGAMMA);<br />}<br /><br />// Задаёт ключ шифрования (256 бит = 32 байта)<br />void SetKey(UINT32 *cryptKey)<br />{<br /> UINT32 i;<br /> for (i = 0; i &lt; CRYPT_KEY_LEN; i++)<br />  CRYPT_KEY[i] = cryptKey[i];<br /><br /> //Ключ должен являться массивом статистически <br /> //независимых битов, принимающих с равной <br /> //вероятностью значения 0 и 1.<br />}</pre></div>
